from __future__ import annotations

import random
from typing import Any


def assign_buildings_within_bg(
    *,
    persons: Any,
    buildings: Any,
    person_id_col: str = "person_id",
    bg_col: str = "bg_geoid",
    building_id_col: str = "bldg_id",
    weight_col_candidates: tuple[str, ...] = ("res_capacity", "footprint_area_m2"),
    seed: int = 0,
) -> Any:
    """
    Two-stage spatial anchoring (v0):
    1) persons already have a BG (or tract) assignment (generated by the diffusion model or a sampler).
    2) within each BG, assign each person to a building by sampling proportional to a capacity proxy.

    Inputs are expected to be pandas DataFrames. We import pandas/numpy lazily to keep base CLI light.
    """
    try:
        import numpy as np  # type: ignore
        import pandas as pd  # type: ignore
    except Exception as e:  # pragma: no cover
        raise RuntimeError("assign_buildings_within_bg requires pandas and numpy.") from e

    if not isinstance(persons, pd.DataFrame) or not isinstance(buildings, pd.DataFrame):
        raise TypeError("persons/buildings must be pandas DataFrame")

    for col in [person_id_col, bg_col]:
        if col not in persons.columns:
            raise ValueError(f"persons missing column: {col}")
    for col in [building_id_col, bg_col]:
        if col not in buildings.columns:
            raise ValueError(f"buildings missing column: {col}")

    weight_col = None
    for cand in weight_col_candidates:
        if cand in buildings.columns:
            weight_col = cand
            break

    rng = np.random.default_rng(int(seed))
    random.seed(int(seed))

    buildings_small = buildings[[building_id_col, bg_col] + ([weight_col] if weight_col else [])].copy()
    if weight_col:
        buildings_small[weight_col] = pd.to_numeric(buildings_small[weight_col], errors="coerce").fillna(0.0)
        buildings_small[weight_col] = buildings_small[weight_col].clip(lower=0.0)

    bldg_by_bg: dict[str, tuple[np.ndarray, np.ndarray | None]] = {}
    for bg, group in buildings_small.groupby(bg_col, sort=False):
        bldg_ids = group[building_id_col].to_numpy()
        weights = group[weight_col].to_numpy(dtype=float) if weight_col else None
        if weights is not None:
            s = float(weights.sum())
            if s > 0:
                weights = weights / s
            else:
                weights = None
        bldg_by_bg[str(bg)] = (bldg_ids, weights)

    assigned_bldg: list[Any] = []
    for bg in persons[bg_col].astype(str).tolist():
        if bg not in bldg_by_bg:
            assigned_bldg.append(None)
            continue
        bldg_ids, probs = bldg_by_bg[bg]
        if len(bldg_ids) == 0:
            assigned_bldg.append(None)
            continue
        idx = int(rng.choice(len(bldg_ids), p=probs))
        assigned_bldg.append(bldg_ids[idx])

    out = persons[[person_id_col, bg_col]].copy()
    out[building_id_col] = assigned_bldg
    return out

